# Laboraufgaben


Es soll eine Höhenmesser entwickelt werden, der ein Höhenprofil aufnehmen kann. Dazu wird in diesem Labor die Informatik - Komponente entwickelt.


---

![Handskizze](Aufgabenstellung_Bilder/b5b_Handskitze_klein.jpg){width="80%" fig-align="center"}



Für die Entwicklung ist schon ein Hardware-Aufbau (Black-Box) vorhanden. Diese bietet verschiedene Grundfunktionen an, die anhand der Aufgaben erweitert werden sollen.

## Beschreibung Hardware-Blackbox:

::: {#fig-zwei-bilder layout-ncol="3"}
![Ultraschal Sensor](Aufgabenstellung_Bilder/b1_US_Sensor_a.jpg)

![µController Vorderseite](Aufgabenstellung_Bilder/b3_Controller_Vorderseite.jpg)


![µController Rückseite](Aufgabenstellung_Bilder/b2_Controller_R%C3%BCckseite.jpg)

Komponenten der Black-Box.
:::


<!-- ![Ultraschal Sensor](Aufgabenstellung_Bilder/b1_US_Sensor_a.jpg){width="50%" fig-align="center"} -->

Die Blackbox ist ein Gehäuse in dem ein µ Controller Signale von einem Ultraschall Sensor (US-Sensor) erfasst diese verarbeitet und über die USB Schnittstelle ausgibt.
Die gesendeten Daten sind im INT (Integer) Format und werden mit einer Frequenz von 1Hz ausgegeben
Die Spannungsversorgung erfolgt auch über den USB Anschluss (5V/0,500mA).

---

## Rahmenbedienung

- Es muss in C programmiert werden.
- Verwendung einer sqlite-Datenbank
- Verwendung von `structs`
- Aufteilen des Codes in Header (.h) und Source (.c) Dateien
- Verwendung von CMake als Buildsystem
- Jede Laboraufgabe wird auf einem eigenen Branch in github oder gitlab entwickelt.
- Die Implementierung erfolgt in dem während der Vorlesung erstellten C-Projekt-Template.

## Laborsetup

Die Daten von der Black Box werden über die serielle Schnittstelle (USB) gesendet und können sowohl unter Windows, Linux oder MacOS Betriebssystem bearbeitet werden. 

Zum Einrichten des jeweiligen Systems siehe Beschreibungen im Tutorial.

Implementierung erfolgt auf den **Jetsons** aus dem Digitalisierungslabor. Diese wird durch die Dozenten bereitgestellt und supportet. Ein Austausch des Codes erfolgt über git (github oder gitlab).

> Das C-Project muss in den beschriebenen Setups **ohne devcontainer** verwendet werden, da schon ein Linux als host System vorliegt und die Serielle Schnittstelle nicht an den devcontainer weiter gereicht wird.

## Abnahme

- Die Laboraufgaben werden einzeln abgenommen.
- Der Code wie auch die erzeugten Visualisierungen müssen erklärt werden.
- Der Code muss sauber mit Methoden, structs und unterschiedlichen .h und .c Dateien strukturiert sein. (vgl. Vorlesungsprojekt)
- Die weiteren Rahmenbedienungen müssen eingehalten werden.



## Abgabe Ausarbeitung

 - Laden Sie auf Moodle folgende Dateien hoch
 - 4x .csv Dateien ( messung_1.csv, messung_2.csv, messung_3.csv, messung_4.csv )
 - C Programm
 - Screenshot der ausgegebenen Grafik in .png oder .jpeg Format

::: {.callout-note}
## Abgabefrist 

Abgabefrist wird im Labor bekannt gegeben.
:::


## Spielregeln

 - Labortermine sind Pflichttermine.
 - Ausarbeitung daheim ist erlaubt.
 - Team mit maximal 3 Teilnehmern ist erlaubt. Allerdings kann der  
   gesamte Kenntnisstand vom jedem Teilnehmer erfragt werden.



## Aufgaben


```{mermaid}


---
title: Programm Struktur
---

flowchart TD

    Menue -->|Manuell| D[Aufgabe 1  - DA    ]
    Menue -->|Manuell| E[Aufgabe 2 - TEST   ]
    Menue -->|Automatik| F[Aufgabe3 - AUTO  ] 
    F --> |Grafisch| G[Diagramm]
    Menue -->|Automatik| H[Aufgabe4 - FILTER  ] 
    Menue -->|Automatik| I[Aufgabe5 - FUN  ] 
    

```


### Aufgabe 1

Plausibilität der eingelesen Werte. Modus "DA" - DatenAufnahme

Ziel: Es ist ein C Programm zu entwickeln, mit dem der von Hand gemessene Abstand und der Blackbox gelieferter Wert auf Tastendruck in einer sql-Datenbank gespeichert wird und diese Datenbank als csv-Datei **messung_x.csv** exportiert werden kann. 


#### Labortask Beschreibung

::: {.callout-note}
## Aufbau zur Messung

Der Aufbau zur Messung der Abstandswerte kann auch im parallel stattfindenden Labor entwickelt werden.
:::
     
1.   US-Sensor in einer festen Position zu einem Objekt abstellen
2.   Den Abstand vom Sensor zur Fläche mit einem Lineal messen und über die  
         Kommandozeile (in Zentimeter) eingeben und mit Enter bestätigen. Dieser Wert soll als realer Abstandswert in der csv-Datei gespeichert werden. (siehe nachfolgende Tabelle)
3.   In der nachfolgenden Spalte den vom Sensor gelieferte Wert 
         speichern (auch Wert in Zentimeter)
4.   In der nachfolgenden Spalte die berechnete Differenz der beiden Werte eintragen
5.   20 Messungen Anfang = 10 cm, Schrittweite = 2 cm  durchführen. 
6.   Nach 20 Punkten soll die Eingabe nicht mehr möglich sein und das Programm springt automatisch zum Menue Auswahl über.
7.  Speichern der Daten in einer Datenbank (sqlite). Das Datenbank Layout ist passend gewählt. Aus der Datenbank kann eine Tabelle als  
     csv Name: **messung_1.csv** exportiert werden.
8.   Option: Plot mit reeler und den vom Sensor gelieferte Werte in Excel programmieren und graphisch ausgeben.
9.   Option: In der Datenbank können auch mehrere Messungen von unterschiedlichen Sensoren / Black-Boxen gespeichert werden.

| Messung Nr.  | ABSTAND              |                      |    Abweichung | 
|--------------|----------------------|---------------------|---------------| 
|              | Reeler Wert          | Vom Sensor erfasster Wert         |               | 
|              | über Tastatureingabe | über USB eingelesen |               | 
| 1            |                      |                     |               | 
| 2            |                      |                     |               | 
| ...          |                      |                     |               | 
| n-1          |                      |                     |               | 
| n            |                      |                     |               | 

---

### Aufgabe 2

Kalibrierung des Sensors mit einer Look-Up Tabelle.  Modus "TEST"

- Die Ermittlung soll auf Basis der **messung_1.csv** erfolgen.
- Die CSV soll in die sql-Datenbank importiert werden.
- Der Sensorwert soll in den realen Abstandswert mit einer Look-Up Tabelle umgerechnet werden.
- Durch den Tausch der Messwert-csv-Datei ist es möglich das Programm auf einen anderen Wertebereich festzulegen oder einen andere Blackbox zu verwenden.
- Zwischen den Datenpunkten aus der Look-Up Tabelle soll linear interpoliert werden, um aus dem Sensorwert den korrekten Abstand zu berechnen.
<!-- - Option: Statt der Lookup-Tabelle kann auch eine lineare Regression gemäß folgender Formel implementiert werden: [Link](https://studyflix.de/statistik/lineare-regression-2147) -->

Siehe folgende Skizze für die Lookup-Tabelle:

![Look-Up Tabelle und Interpolation](Aufgabenstellung_Bilder/lokk-up-table.ex.excalidraw.png){width="90%" fig-align="center"}

Funktion der Look-Up Tabelle:

1. Der Sensorwert wird eingelesen.
2. Die nächsten zwei Sensorwerte aus der Look-Up Tabelle werden gesucht.
3. Zwischen diesen beiden Werten wird linear interpoliert, um den realen Abstand zu berechnen.
4. Der berechnete reale Abstand wird ausgegeben.



#### Labortask Beschreibung
     
1.   US-Sensor in einer festen Position zu einem Objekt abstellen
2.   Das Messen des Abstands vom Sensor zur Fläche wird mit einem Tastendruck auf Enter ausgelöst. Dieser Wert wird als gelesener 
     Abstandswert (in Zentimeter) in einer Datenbank (sqlite) gespeichert und dann von dort in einer 
     csv-Datei **messung_2.csv**  exportiert. (Muster siehe nachfolgende Tabelle)
3.   Zu dem rohen Sensorwert soll der mit der Lookup-Tabelle korrigierte Abstand in der Datenbank abgelegt werden. 
4.   Mehrere Messungen durchführen ( minimum 20 ) . Abstand ist diesmal willkürlich ausgewählt.
5.   Der Modus soll so lange laufen, bis ein spezieller Tastendruck (z.B. "q") erfolgt.
     das Programm springt automatisch zum Menue zurück.
6. Option: Mit dem Beenden des Aufnahmemodus wird die CSV-Datei geschrieben.
7. Option: Plot mit Soll und Ist Wert in Excel programmieren und graphisch ausgeben.
 

| Messung Nr.  | ABSTAND              |                     |    Abweichung | 
|--------------|----------------------|---------------------|---------------| 
|              | Vom Sensor Wert      | Interpolierter Wert |               | 
|              | über USB eingelesen  | Berechnet           |               | 
| 1            |                      |                     |               | 
| 2            |                      |                     |               | 
| ...          |                      |                     |               | 
| n-1          |                      |                     |               | 
| n            |                      |                     |               | 

---



### Aufgabe 3 

Automatisch messen. Modus "AUTO"

#### Labortask Beschreibung 

1.  für ca. 10 Sekunden eine Messung bzw. ein Bewegungsablauf starten
2.  Zeitstempel der erfassten Werte und die Werte in einer Datenbank (sqlite) speichern und dann in einer .csv Tabelle **messung_3.csv** 
    exportieren.
3.  Visualisieren der Höhenkarte anhand der Zeitstempel mit der ASCII-Histogramm-Visualisierung - in **C** programmiert.
    1.  Immer wenn ein neuer Sensorwert eingelesen wird wird das Histogram in der Kommandozeile aktualisiert.
4.  Ist die Zeit zwischen zwei Zeitstempeln immer gleich?
5.  Wenn nein die max und min sowie auch die Durchnittsabtastzeit berechnen.
6.  Im Windows/Linux/MacOs System mehrere Task's starten (youtube Video, Maus bewegen usw. ) und gleiche Messung nochmal durchführen.
7.  Wie verändern sich jetzt die Werte der Zeitstempel? Speichern Sie die Daten in einer in einer Datenbank (sqlite) und exportieren sie 
    diese  in einer.csv Tabelle - **messung_4.csv** 
    
### Aufgabe 4

 Daten Filtern. Modus "FILTER"

   - Filter Sie die in **messwert3.csv** gespeicherten Abstands Werte.
   - Programmieren Sie einen Mittelwert-Filter über 3 Werte (z.B. u(m)=(SUMME( y(m-1):y(m+1))/3) ) 
   - Ploten Sie beide Werte Reihen in einem Diagramm und die dazugehörige Differenz zwischen den beiden Wertereihen in einem neuem Diagramm (in Excel)

### Aufgabe 5 

 Fun: Make it a game. Modus "FUN"

#### Labortask Beschreibung 

1.  ASCII Art level durch Höhenkarte. Das C Programm gibt eine Höhenkarte auf der Kommandozeile aus.
2.  U-Boot mit W - up, S - down gesteuert durch die Höhenkarte navigieren.
3.  Von links nach rechts fährt das Uboot automatisch.
4.  Beenden Sie das Spiel wenn das U-Boot auf Grund läuft (also mit der Höhenkarte kollidiert).

  

<!-- 
---

Beschreibung Betriebssystem anpassen:

##  Daten im **L I N U X** Betriebs-System empfangen und auslesen/speichern

::: {.callout-warning collapse="true"}
## Vorbereitung jetsons - Falls noch nicht durch Laborpersonal vorbereitet

1. (optional) Update Packages and fix issues
   ```bash
   sudo apt-get update -y
   sudo apt --fix-broken install -y
   sudo dpkg --configure -a
   ```
2. install cmake
   ```bash
   sudo apt-get install -y cmake ninja-build
   ```
3. install sqlite
   ``` bash
   sudo apt-get install -y sqlite3 libsqlite3-dev
   ```
4. Install brave browser
   ```bash
   curl -fsS https://dl.brave.com/install.sh | sh
   ```
   oder:
   ```bash
   sudo apt-get install brave-browser
   ```
5. Install minicom, um die Werte der Blackbox auszulesen
   ```bash
   sudo apt-get install minicom
   ```
6. Setzen der Rechte für ttyUSB0:
   ```bash
   sudo usermod -aG dialout $USER  #Wenn $USER nicht vorhanden, dann $johbaum8 eingeben
   ```
   

:::


### Mit minicom testen

Mit minicom können Sie testen, ob die Blackbox Werte liefert:

```bash
sudo minicom -b 115200 -D /dev/ttyUSB0
#oder 
minicom -b 115200 -D /dev/ttyUSB0

```

### Schritt-für-Schritt-Anleitung

1. Black Box an die USB Schnittstelle vom Jetson anschliessen
2. Moodle Beschreibung "ITEC-Lec04.04 Grundlagen C" aus "Einführung in C" ausführen 
3. Punkt 4 (mkdir .devcontainer) aus 1.1.1 Schritt 1 " Ordnerstruktur erstellen" nicht ausführen. Kein DevContainer!
4. Kapitel 1.1.2 Schritt 2 "Devcontainer konfigurieren" nicht ausführen
5. Mit Schritt 3 (1.1.) weitermachen.
 Hinweis: C Code zum auslesen vom Com Port ist am Ende der Beschreibung zu finden. 



##  Daten im **W I N D O W S** Betriebs-System empfangen und auslesen/speichern



# Anhang Installationsvorgehen zur Verwendung von USB serial Kommunikation auf Windows host Systemen mit WSL 2 

::: {.callout-important}
## Important Note

Open the **PowerShell as Administrator**!
:::

## Update WSL 2 and install usbipd‑win on Windows
	
Ensure WSL is up‑to‑date. Open a **PowerShell as Administrator** terminal and run:
```powershell
wsl --update
```
The Microsoft command‑line blog notes that WSL needs to be on a 5.10 kernel or newer and suggests updating before using USB/IP.

### Install usbipd‑win. 

Use winget￼ to install the latest release.  In an elevated PowerShell prompt run:

```powershell
winget install --interactive --exact dorssel.usbipd-win
```

[Installing usbipd‑win registers a service on Windows that shares local USB devices to WSL.](https://devblogs.microsoft.com/commandline/connecting-usb-devices-to-wsl/#:~:text=To%20get%20started%20with%20this,running%20a%20WSL%202%20distro)

### List available USB devices. 

From an elevated command prompt run:

```powershell
usbipd list
```

This command prints each device’s `BUSID`, vendor/product IDs and current state.  Note the `BUSID` corresponding to the serial adapter you want to share.

```powershell
Connected:
BUSID  VID:PID    DEVICE                                                        STATE
1-8    5986:2115  Integrated Camera                                             Not shared
1-9    06cb:00be  Synaptics UWP WBDI SGX                                        Not shared
1-14   8087:0026  Intel(R) Wireless Bluetooth(R)                                Not shared
4-3    046a:0114  USB-Eingabegerät                                              Not shared
4-4    10c4:ea60  CP2102 USB to UART Bridge Controller                          Not shared

Persisted:
GUID    
```

`CP2102 USB to UART Bridge Controller` is the description of the serial adapter we need.  Its `BUSID` is `4-4`.

### Bind and attach the device. 

First, make the device sharable with `usbipd bind --busid=<BUSID>`.  

```powershell
usbid bind --busid <BUSID>
```
Then attach it to WSL using:

::: {.callout-important}
## Open WSL terminal

To attach the device to WSL, open a WSL terminal such as Ubuntu from:

Startmenue → Ubuntu xx.xx

:::

```powershell
usbipd attach --busid <BUSID> --wsl
```

The usbipd documentation explains that bind is persistent, whereas attach connects the device to the running WSL VM.

## Install USB/IP client tools inside WSL

In order for WSL to communicate with the usbipd service, install the Linux USB/IP user‑space tools:

```bash
sudo apt update
# Install the appropriate linux‑tools package for your kernel and the hwdata database
sudo apt install linux-tools-$(uname -r) hwdata usbutils
# Register the usbip client binary if your distribution does not do so automatically
sudo update-alternatives --install /usr/local/bin/usbip usbip \
    /usr/lib/linux-tools-$(uname -r)/usbip 20
```

Microsoft’s guidance demonstrates installing `linux-tools` and `hwdata`, then registering `usbip` with update-alternatives ￼.  The usbutils package provides the `lsusb` utility used later.

After attaching the device from Windows, verify that WSL can see it:

```bash
lsusb
```

You should see an entry corresponding to your serial adapter.  Depending on the driver, it will also create a character device such as `/dev/ttyUSB0` or `/dev/ttyACM0`.  You can find it with:


```bash
ls -l /dev/ttyUSB* /dev/ttyACM* 2>/dev/null
```

Im VSCode Terminal folgende Befehle ausführen:
RUN apt-get update
RUN apt-get install -y sqlite3 libsqlite3-dev ninja-build
USER root
RUN apt-get install -y --no-install-recommends usbutils minicom
RUN usermod -aG dialout vscode
USER vscode
WORKDIR /workspaces



This configuration installs `usbutils` and `minicom` so you can inspect USB buses and open serial.  Adding the vscode user to the dialout group avoids running commands as root.


---

If you know the exact device file (/dev/ttyUSB0 or similar) you may instead map only that device using "--device=/dev/ttyUSB0" for finer control.  The example above maps all USB devices.

---

# Anhang: Daten im **Windows** Betriebs-System empfangen und auslesen/speichern


##  Daten im **Mac OS** Betriebs-System empfangen und auslesen/speichern

Hier ist der gleiche C Code anwendbar.


:::{.callout-note collapse="true"}

## C Code für Linux MacOS und Windows(im WSL2)

```C

C File zum auslesen vom COM Port - Black Box im Linux Betriebssystem

#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <termios.h>
#include <unistd.h>

#define READ_CHUNK 64

//Um die Simulation der Sensorwerte anzuschalten muss "SIM 0"  gesetzt werden.
#define SIM 1

//Praeprozessor Makro fuer die Oeffnungsflags des seriellen Ports
#ifdef __APPLE__
#define OPEN_FLAGS O_NONBLOCK
#else
#define OPEN_FLAGS O_RDWR
#endif

/**
 * Configures the serial port with the desired settings.
 * 
 * Important settings are:
 * 
 * - Baudrate: 115200
 * - Initial read timeout: 0.5s
 * - no min bytes for read (non-blocking)
 * 
 * @param fd The file descriptor of the opened serial port.
 * @returns 0 on success, -1 on failure.
 */
int configure_serial(int fd) {
    struct termios tty;
    if (tcgetattr(fd, &tty) != 0) {
        perror("tcgetattr");
        return -1;
    }

    cfsetispeed(&tty, B115200);
    cfsetospeed(&tty, B115200);

    tty.c_cc[VTIME] = 5; // 0.5s Timeout
    tty.c_cc[VMIN] = 0; //has to be 0 for non-blocking read for mac os

    tcflush(fd, TCIFLUSH);

    if (tcsetattr(fd, TCSANOW, &tty) != 0) {
        perror("tcsetattr: Fehler beim Setzen der Einstellungen");
        return -1;
    }

    return 0;
}

/**
 * Handles a complete line read from the serial port.
 * @param line The line to handle (null-terminated string).
 * @returns the distance as float in cm, or -1.0f on error.
 */
float convert_to_sensor_val(const char *line) {
    char *endptr = NULL;
    errno = 0;
    float value = strtof(line, &endptr);

    if (!(errno == 0 && endptr != line)) {
        value = -1.0f;
        fprintf(stderr, "Warning: could not parse float from '%s' - Errno: %s\n", line, strerror(errno));
    }

    return value;
}


typedef struct _sim_data {
    size_t length;
    size_t index;
    float data[32];
} sim_data;

/**
 * Simulation of the sensor read
 * @return the number of bytes read
 */
ssize_t read_sim(int serial_fd,  char* chunk, size_t chunk_len){

    static sim_data s_data = {32, 0, 
        {10.25f, 12.80f, 15.60f, 18.45f, 21.10f, 23.95f, 26.70f, 29.55f,
        32.30f, 35.15f, 37.90f, 40.75f, 43.50f, 46.35f, 49.10f, 51.95f,
        54.70f, 57.55f, 60.30f, 63.15f, 65.90f, 68.75f, 71.50f, 74.35f,
        77.10f, 79.95f, 82.70f, 85.55f, 88.30f, 91.15f, 93.90f, 99.60f}};

    //sleep fuer 1 sec
    sleep(1);

    //neuen Werte aus liste holen
    float value = s_data.data[s_data.index];

    //update index
    s_data.index = (++s_data.index)%s_data.length; 


    if (chunk_len == 0) {
        return 0;
    }

    int written = snprintf(chunk, chunk_len, "%f\n", value);
    if (written < 0) {
        return -1;
    }

    if ((size_t)written >= chunk_len) {
        written = (int)(chunk_len - 1);
    }

    return written;
}

int connect_to_sensor(char * tty_path){
    //Oeffnen des seriellen Ports

    int serial_fd = open(tty_path, OPEN_FLAGS);

    if (serial_fd < 0) {
        fprintf(stderr, "Failed to open %s: %s\n", tty_path, strerror(errno));
        return -1;
    }

    //Konfiguration des seriellen Ports
    if (configure_serial(serial_fd) != 0) {
        fprintf(stderr, "Failed to configure %s: %s\n", tty_path, strerror(errno));
        close(serial_fd);
        return -1;
    }
    return serial_fd;
}

int main(void) {
#if SIM
    char* tty_path = "/dev/ttyUSB0";
    int serial_fd = connect_to_sensor(tty_path);
#else
    int serial_fd = 0;    //wird in der Simulation nicht benoetigt.
#endif

    //Normalerweise wird stdout gepuffert, was bei der seriellen Ausgabe
    //zu Verzögerungen führen kann. Mit diesem Aufruf wird die Pufferung deaktiviert.
    setvbuf(stdout, NULL, _IONBF, 0);

    //Buffer zum Lesen und Verarbeiten von Daten pro Sensor
    char chunk[READ_CHUNK];
    char line_buffer[2*READ_CHUNK];
    size_t line_len = 0;

    while (1) {

        #if SIM
        ssize_t bytes_read = read(serial_fd, chunk, sizeof(chunk));
        #else
        ssize_t bytes_read = read_sim(serial_fd, chunk, sizeof(chunk));
        #endif

        if (bytes_read < 0) {
            if (errno == EINTR) {
                continue;
            }
            perror("read");
            break;
        }
        if (bytes_read == 0) {
            continue;
        }

        for (size_t i = 0; i < bytes_read; ++i) {
            char c = chunk[i];

            if (c == '\r') {
                continue;
            }

            if (c == '\n') {
                if (line_len > 0) {
                    line_buffer[line_len] = '\0';
                    float value = convert_to_sensor_val(line_buffer);
                    printf("Sensor Value: %.3f cm\n", value);

                    //TODO: Weiterverarbeiten des Sensorwerts
                    
                    line_len = 0;
                }
                continue;
            }

            if (line_len + 1 >= sizeof(line_buffer)) {
                fprintf(stderr, "Warning: incoming line too long, discarding.\n");
                line_len = 0;
                continue;
            }

            line_buffer[line_len++] = c;
        }
    }

    close(serial_fd);
    return 0;
}

```
:::

 -->
