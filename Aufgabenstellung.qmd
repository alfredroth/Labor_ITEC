# Laboraufgabe

Es soll eine H√∂henmesser entwicklet werden, der ein H√∂henprofil aufnehmen kann. Dazu wird in diesem Labor die Informatik-Komponente entwickelt.


---

![Handskitze](Aufgabenstellung_Bilder/b5_Handskitze_klein.jpg){width="80%" fig-align="center"}

---

F√ºr die Entwicklung ist schon eine Hardware-Aufbau vorhanden. Diese bietet verschiedene Grundfunktionen an, die anhand der Aufgaben erweitert werden sollen.

## Beschreibung Hardware-Blackbox:

<!--
![KI stellt diverse Herausforderungen an eine Datenstrategie[^fn6]](https://www.ihk-muenchen.de/ihk/Digitalisierung/KI-Webinarreihe-2020/Webinar-5-Datenstrategie.pdf){#fig-ki-herausf fig-align="center" width="80%"}

[^fn6]: [@Dr.HendrikBrakemeier.2020]
-->
---

![Ultraschal Sensor](Aufgabenstellung_Bilder/b1_US_Sensor_a.jpg){width="50%" fig-align="center"}

---


![¬µController Vorderseite](Aufgabenstellung_Bilder/b3_Controller_Vorderseite.jpg){width="30%" fig-align="left"}

---


![¬µController Vorderseite](Aufgabenstellung_Bilder/b2_Controller_R%C3%BCckseite.jpg){width="30%" fig-align="right"}

---


Die Blackbox ist ein Geh√§use in dem ein ¬µ Controller Signale von einem Ultraschall Sensor (US-Sensor) erfasst diese verarbeitet und √ºber die USB Schnittstelle ausgibt.
Die gesendeten Daten sind im INT Format und werden mit einer Frequenz von 1Hz ausgegeben
Die Spannungsversorgung erfolgt auch √ºber den USB Anschluss (5V/0,500mA).


[//]:<> (TODO: Beschreibung der Ansteuerung (Win und Linux))



Auslesen der empfangenen Daten im Windows Betriebs-System 

Serielle Port Schnittstelle definieren.
(USB = Universal Serial Bus.)

*********************************************************************************************************
[//]:<> (

---

Hier ist eine grundlegende Anleitung, wie du in C unter Windows Daten von einem USB-Port auslesen und speichern kannst. Dabei gehen wir davon aus, dass es sich um ein USB-Ger√§t handelt, das sich als serielles Ger√§t (z.‚ÄØB. ein USB-zu-Seriell-Konverter wie ein Arduino oder √§hnliches) am System anmeldet ‚Äì das ist der g√§ngigste und einfachste Fall.

---

## ‚úÖ Voraussetzungen

1. **Dein USB-Ger√§t muss sich als COM-Port anmelden.**

   * √úberpr√ºfe das in der Windows-Ger√§teverwaltung unter ‚ÄûAnschl√ºsse (COM & LPT)‚Äú.
   * Beispiel: *"USB Serial Port (COM3)"*

2. **Du ben√∂tigst ein installiertes C-Compiler-Toolset**, z.‚ÄØB.:

   * [MinGW](https://sourceforge.net/projects/mingw/)
   * Visual Studio (mit C/C++ Unterst√ºtzung)

---

## üìÑ Schritt-f√ºr-Schritt-Anleitung

### üîπ 1. COM-Port herausfinden

√ñffne den Ger√§te-Manager und suche unter **"Anschl√ºsse (COM & LPT)"** nach deinem Ger√§t, z.‚ÄØB. **COM3**.

---

### üîπ 2. C-Code zum Auslesen eines COM-Ports

Speichere folgenden C-Code in eine Datei, z.‚ÄØB. `read_com_port.c`:

```c
#include <windows.h>
#include <stdio.h>

int main() {
    HANDLE hSerial;
    DCB dcbSerialParams = {0};
    COMMTIMEOUTS timeouts = {0};
    char portName[] = "\\\\.\\COM3";  // √Ñndere COM3 auf deinen tats√§chlichen Port
    char buffer[1024];
    DWORD bytesRead;

    // COM-Port √∂ffnen
    hSerial = CreateFileA(portName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hSerial == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "Fehler beim √ñffnen des Ports %s\n", portName);
        return 1;
    }

    // Serielle Einstellungen
    dcbSerialParams.DCBlength = sizeof(dcbSerialParams);
    if (!GetCommState(hSerial, &dcbSerialParams)) {
        fprintf(stderr, "Fehler beim Lesen der Port-Einstellungen\n");
        CloseHandle(hSerial);
        return 1;
    }

    dcbSerialParams.BaudRate = CBR_9600;    // Baudrate ggf. anpassen
    dcbSerialParams.ByteSize = 8;
    dcbSerialParams.StopBits = ONESTOPBIT;
    dcbSerialParams.Parity   = NOPARITY;

    if (!SetCommState(hSerial, &dcbSerialParams)) {
        fprintf(stderr, "Fehler beim Setzen der Port-Einstellungen\n");
        CloseHandle(hSerial);
        return 1;
    }

    // Timeout-Einstellungen
    timeouts.ReadIntervalTimeout = 50;
    timeouts.ReadTotalTimeoutConstant = 50;
    timeouts.ReadTotalTimeoutMultiplier = 10;

    if (!SetCommTimeouts(hSerial, &timeouts)) {
        fprintf(stderr, "Fehler beim Setzen der Timeouts\n");
        CloseHandle(hSerial);
        return 1;
    }

    // Datei zum Speichern √∂ffnen
    FILE *outFile = fopen("usb_output.txt", "w");
    if (!outFile) {
        fprintf(stderr, "Konnte Ausgabedatei nicht √∂ffnen\n");
        CloseHandle(hSerial);
        return 1;
    }

    printf("Lese vom USB-Ger√§t...\n");

    while (1) {
        if (ReadFile(hSerial, buffer, sizeof(buffer) - 1, &bytesRead, NULL)) {
            if (bytesRead > 0) {
                buffer[bytesRead] = '\0';  // Null-terminieren
                printf("%s", buffer);      // Ausgabe auf Konsole
                fprintf(outFile, "%s", buffer); // Schreiben in Datei
                fflush(outFile);           // Sicherstellen, dass sofort geschrieben wird
            }
        } else {
            fprintf(stderr, "Fehler beim Lesen vom COM-Port\n");
            break;
        }
    }

    fclose(outFile);
    CloseHandle(hSerial);
    return 0;
}
```

---

### üîπ 3. Kompilieren

√ñffne die Eingabeaufforderung und kompiliere mit z.‚ÄØB.:

```bash
gcc read_com_port.c -o read_com_port.exe
```

(Erfordert, dass `gcc` installiert und in der PATH-Variable ist.)

---

### üîπ 4. Ausf√ºhren

```bash
read_com_port.exe
```

Wenn dein USB-Ger√§t Daten sendet, siehst du sie auf der Konsole und sie werden in `usb_output.txt` gespeichert.


)

***************************************************

```C
 Windows System 
//Programm zum auslesen eines USB Port's 
#include <windows.h>
#include <iostream>
#include <stdlib.h>

int main() {
    HANDLE hSerial;
    LPCSTR portName = "\\\\.\\COMX"; // Ersetze COMX durch deinen Port (z.‚ÄØB. COM1, COM4)

    hSerial = CreateFile(portName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
........

    dcbSerialParams.BaudRate = CBR_115200;   
    dcbSerialParams.ByteSize = 8;
    dcbSerialParams.StopBits = ONESTOPBIT;
    dcbSerialParams.Parity = NOPARITY;
.........
}
```




LinuxS ystem 

```C
// usb: USB0 Baud; Rate  115200

// mit "cat /dev/ttyUSB0" kann der Port Testweise gelesen werden.

#include <iostream>
#include <fcntl.h>
#include <termios.h>
#include <unistd.h>
#include <cstring>

int main() {
    const char* port = "/dev/ttyUSB0";  // Port Nr.
    int serial_port = open(port, O_RDWR);

   .........
}


```


## Rahmenbedinung

- Es muss in C programmiert werden.

## Abnahme

- Die Laboraufgaben werden einzeln abgenommen.
- Der Code wie auch die erzeugten Visualisierungen m√ºssen erkl√§rt werden.
- Der Code muss sauber mit Methoden, structs und unterschiedlichen .h und .c Dateien strukturiert sein. (vgl. Vorlesungsprojekt)

## Aufgaben

### 1. Plausbilit√§t der eingelesen Werte

Ziel: 

- Ziel ist es ein C Programm zu entwicklen, das den Sensorwert aus der Blackbox auf Tastendruck ausliest und in eine csv-Datei speichert. 
- Das Programm soll einen Kalibrierungsmodus haben. 
- In diesem Modus soll der reale Abstandswert auf der Kommandozeile eingegeben werden und mit Enter best√§tigt werden. Der reale Abstandswert soll ebenfalls in der csv-Datei gespeiochert werden.
- Der Modus kann √ºber die CLI ausgew√§hlt werden (Einzelmessung, Kalibirierung)
- Anhand der h√§ndisch erstellten Tabelle eine Look-Up Tabelle programieren, die als Input die aufgenommene csv-Datei hat. So ist es m√∂glich durch den Tausch der csv-Datei einen anderen Wertebereich festzulegen.
- Zwischen den Datenpunkten aus der Look-Up Tabelle soll linear interpoliert werden, um aus dem Sensorwert den korrekten Abstand zu berechnen.
- Die Visualisierung der Soll-Ist-Abweichung soll in Excel durch den Import der csv-Datei erfolgen.

TODO: √ºberarbeien
Breakdown Kalibrieren:

   - US-Sensor in einer festen Position zu einem Objekt abstellen
   - Mit einem Lineal den Abstand Sensor Objekt messen
   - Eingelesenen Wert konvertieren und den Wert als Meter anzeigen (Faktor!)
   - Auf einem Blatt Papier eine Tabelle f√ºr 20 Abstands Messungen erstellen.
   - 20 Messungen Anfang =0m, Schrittweite = 0,002 m  durchf√ºhren und Werte in Tabelle eintragen
   - Plot mit Soll und Ist Wert programieren und graphisch ausgeben.
   - Anhand der h√§ndisch erstellten Tabelle eine Look-Up Tabelle programieren.
   - Look Up Tabelle interpolieren (lineare Interpolation , 5 Zwischenpunkte)
   - Durch Messungen die Plausbilit√§t √ºberpr√ºfen (3-5 Messungen)
   - Die Ergebnisse in einer Excel Tabelle "Messung Nr. 1" speichern


### 2. Automatisch messen

   - f√ºr ca. 10 Sekunden eine/n Messung/Bewegungsablauf starten
   - Zeitstempel der erfassten Werte und die Werte in einer .csv Tabelle "Messung Nr. 2" speichern
   - Visualisieren der H√∂henkarte anhand der Zeitstempel
   - Ist die Zeit zwischen zwei Zeitstempeln immer gleich?
   - Wenn nein die max und min sowie auch die durchnits Abtast Zeit berechnen.
   - Im Windows mehrere Task's starten (youtube Video, Maus bewegen usw. ) und gleiche Mesusung noch mal durchf√ºhren.
   - Wie ver√§ndern sich jetzt die Werte der Zeitstempel? Speichern Sie die Daten in einer neiuen in einer .csv Tabelle
     "Messung Nr. 3"


### 3. Daten Filtern

   - Filter Sie die eingelesenen Werte.
   - Programieren Sie ein Mittelwert Filter √ºber 3 Werte  z.B. u(m)=(SUMME( y(m-1):y(m+1))/3
   - Ploten Sie beide Werte Reihen in einem Diagramm und die dazugeh√∂rige Differenz zwichen den beiden Wertereihen
     in einem neuem Diagramm

### 4. Fun: Make it a game

TODO:

- ASCII Art level durch h√∂henkarte
- U-Boot mit W - up, S - down gesteuert
- von links nach rechts f√§hrt das Uboot automatisch
- Bei kollisiotn mit der H√∂he ...

  - Geben Sie √ºber die Lautsprechen des PC's ein Sound aus abh√§ngig vom gemessenen Abstand
  - 20 cm = 1kHz  1cm = 50Hz
  - Das C Programm gibt eine H√∂henkarte als Bild aus.
  - Das C Programm gibt auf der Kommandozeile interaktive die H√∂henkarte aus (ascii-art, ascii-style)
  - 
